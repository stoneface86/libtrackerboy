
#include "trackerboy/synth/Osc.hpp"
#include "trackerboy/gbs.hpp"

#include <algorithm>
#include <cassert>
#include <cmath>
#include <cstddef>


namespace {

template <typename T>
void circlecopy(T src[], size_t srcSize, int destPos, T dest[], size_t dstSize) {
    for (size_t i = 0; i != srcSize; ++i) {
        int index;
        if (destPos < 0) {
            auto dstSizeInt = static_cast<int>(dstSize);
            index = ((destPos % dstSizeInt) + dstSizeInt) % dstSizeInt;
        } else if (destPos >= dstSize) {
            index = destPos % dstSize;
        } else {
            index = destPos;
        }
        dest[index] += src[i];
        ++destPos;
    }
}


}


namespace trackerboy {

const float Osc::STEP_TABLE[Osc::STEP_PHASES][Osc::STEP_WIDTH] = {
    // this table was generated by genstep.py
    // genstep.py 48000 64 32 16
    /* Phase:  0.000 */    {  0.000687230f, -0.001788836f,  0.002571344f, -0.004002845f,  0.007034825f, -0.014529911f,  0.235105664f,  0.550034881f,  0.235295504f, -0.014529911f,  0.007034825f, -0.004002845f,  0.002571344f, -0.001788836f,  0.001315700f, -0.001008166f },
    /* Phase: -0.031 */    {  0.000690953f, -0.001799706f,  0.002593471f, -0.004054342f,  0.007189595f, -0.015447486f,  0.221296206f,  0.549617767f,  0.249267891f, -0.013304434f,  0.006793251f, -0.003907583f,  0.002522443f, -0.001759801f,  0.001296770f, -0.000994989f },
    /* Phase: -0.062 */    {  0.000687247f, -0.001792693f,  0.002589311f, -0.004063041f,  0.007260215f, -0.016077779f,  0.207687557f,  0.548371136f,  0.263367116f, -0.011750909f,  0.006462957f, -0.003767987f,  0.002446538f, -0.001712488f,  0.001264614f, -0.000971783f },
    /* Phase: -0.094 */    {  0.000676291f, -0.001768247f,  0.002559584f, -0.004030289f,  0.007250012f, -0.016441761f,  0.194313258f,  0.546299458f,  0.277555197f, -0.009849798f,  0.006042823f, -0.003583910f,  0.002343653f, -0.001646963f,  0.001219301f, -0.000938614f },
    /* Phase: -0.125 */    {  0.000658330f, -0.001726975f,  0.002505239f, -0.003957781f,  0.007162931f, -0.016560614f,  0.181205109f,  0.543410063f,  0.291793019f, -0.007582299f,  0.005532583f, -0.003355641f,  0.002214082f, -0.001563469f,  0.001161030f, -0.000895644f },
    /* Phase: -0.156 */    {  0.000633671f, -0.001669629f,  0.002427438f, -0.003847540f,  0.007003459f, -0.016455622f,  0.168393046f,  0.539713323f,  0.306040436f, -0.004930481f,  0.004932873f, -0.003083922f,  0.002058389f, -0.001462433f,  0.001090132f, -0.000843135f },
    /* Phase: -0.188 */    {  0.000602678f, -0.001597104f,  0.002327534f, -0.003701883f,  0.006776563f, -0.016148042f,  0.155905098f,  0.535222352f,  0.320256352f, -0.001877408f,  0.004245280f, -0.002769954f,  0.001877412f, -0.001344463f,  0.001007064f, -0.000781445f },
    /* Phase: -0.219 */    {  0.000565771f, -0.001510418f,  0.002207060f, -0.003523388f,  0.006487624f, -0.015658984f,  0.143767238f,  0.529953003f,  0.334399074f,  0.001592729f,  0.003472385f, -0.002415403f,  0.001672260f, -0.001210346f,  0.000912415f, -0.000711029f },
    /* Phase: -0.250 */    {  0.000523418f, -0.001410705f,  0.002067706f, -0.003314866f,  0.006142366f, -0.015009303f,  0.132003352f,  0.523923993f,  0.348426402f,  0.005494489f,  0.002617797f, -0.002022405f,  0.001444314f, -0.001061045f,  0.000806895f, -0.000632432f },
    /* Phase: -0.281 */    {  0.000476130f, -0.001299199f,  0.001911300f, -0.003079323f,  0.005746786f, -0.014219489f,  0.120635159f,  0.517156661f,  0.362295717f,  0.009841058f,  0.001686188f, -0.001593562f,  0.001195220f, -0.000897697f,  0.000691335f, -0.000546291f },
    /* Phase: -0.312 */    {  0.000424455f, -0.001177223f,  0.001739787f, -0.002819927f,  0.005307097f, -0.013309569f,  0.109682165f,  0.509674728f,  0.375964344f,  0.014644136f,  0.000683316f, -0.001131937f,  0.000926879f, -0.000721599f,  0.000566681f, -0.000453325f },
    /* Phase: -0.344 */    {  0.000368975f, -0.001046172f,  0.001555211f, -0.002539977f,  0.004829650f, -0.012299008f,  0.099161617f,  0.501504421f,  0.389389575f,  0.019913817f, -0.000383957f, -0.000641038f,  0.000641436f, -0.000534207f,  0.000433985f, -0.000354332f },
    /* Phase: -0.375 */    {  0.000310296f, -0.000907499f,  0.001359686f, -0.002242860f,  0.004320879f, -0.011206622f,  0.089088507f,  0.492674291f,  0.402528942f,  0.025658498f, -0.001507654f, -0.000124808f,  0.000341273f, -0.000337120f,  0.000294399f, -0.000250182f },
    /* Phase: -0.406 */    {  0.000249044f, -0.000762702f,  0.001155383f, -0.001932025f,  0.003787235f, -0.010050495f,  0.079475522f,  0.483214915f,  0.415340394f,  0.031884756f, -0.002678678f,  0.000412395f,  0.000028983f, -0.000132070f,  0.000149166f, -0.000141811f },
    /* Phase: -0.438 */    {  0.000185858f, -0.000613306f,  0.000944502f, -0.001610945f,  0.003235131f, -0.008847907f,  0.070333056f,  0.473158956f,  0.427782506f,  0.038597289f, -0.003886812f,  0.000965828f, -0.000292641f,  0.000079091f, -0.000000393f, -0.000030211f },
    /* Phase: -0.469 */    {  0.000121383f, -0.000460850f,  0.000729251f, -0.001283082f,  0.002670879f, -0.007615265f,  0.061669238f,  0.462540925f,  0.439814597f,  0.045798801f, -0.005120736f,  0.001530387f, -0.000620630f,  0.000294405f, -0.000152887f,  0.000083578f },
    /* Phase: -0.500 */    {  0.000056266f, -0.000306870f,  0.000511831f, -0.000951860f,  0.002100643f, -0.006368043f,  0.053489938f,  0.451397002f,  0.451397002f,  0.053489938f, -0.006368043f,  0.002100643f, -0.000951860f,  0.000511831f, -0.000306870f,  0.000198474f },
    /* Phase: -0.531 */    { -0.000008851f, -0.000152887f,  0.000294405f, -0.000620630f,  0.001530387f, -0.005120736f,  0.045798801f,  0.439764827f,  0.462491155f,  0.061669238f, -0.007615265f,  0.002670879f, -0.001283082f,  0.000729251f, -0.000460850f,  0.000313368f },
    /* Phase: -0.562 */    { -0.000073340f, -0.000000393f,  0.000079091f, -0.000292641f,  0.000965828f, -0.003886812f,  0.038597289f,  0.427683443f,  0.473059893f,  0.070333056f, -0.008847907f,  0.003235131f, -0.001610945f,  0.000944502f, -0.000613306f,  0.000427133f },
    /* Phase: -0.594 */    { -0.000136589f,  0.000149166f, -0.000132070f,  0.000028983f,  0.000412395f, -0.002678678f,  0.031884756f,  0.415192991f,  0.483067513f,  0.079475522f, -0.010050495f,  0.003787235f, -0.001932025f,  0.001155383f, -0.000762702f,  0.000538629f },
    /* Phase: -0.625 */    { -0.000198008f,  0.000294399f, -0.000337120f,  0.000341273f, -0.000124808f, -0.001507654f,  0.025658498f,  0.402334630f,  0.492479980f,  0.089088507f, -0.011206622f,  0.004320879f, -0.002242860f,  0.001359686f, -0.000907499f,  0.000646722f },
    /* Phase: -0.656 */    { -0.000257037f,  0.000433985f, -0.000534207f,  0.000641436f, -0.000641038f, -0.000383957f,  0.019913817f,  0.389150262f,  0.501265109f,  0.099161617f, -0.012299008f,  0.004829650f, -0.002539977f,  0.001555211f, -0.001046172f,  0.000750291f },
    /* Phase: -0.688 */    { -0.000313146f,  0.000566681f, -0.000721599f,  0.000926879f, -0.001131937f,  0.000683316f,  0.014644136f,  0.375682354f,  0.509392738f,  0.109682165f, -0.013309569f,  0.005307097f, -0.002819927f,  0.001739787f, -0.001177223f,  0.000848237f },
    /* Phase: -0.719 */    { -0.000365846f,  0.000691335f, -0.000897697f,  0.001195220f, -0.001593562f,  0.001686188f,  0.009841058f,  0.361973822f,  0.516834736f,  0.120635159f, -0.014219489f,  0.005746786f, -0.003079323f,  0.001911300f, -0.001299199f,  0.000939498f },
    /* Phase: -0.750 */    { -0.000414685f,  0.000806895f, -0.001061045f,  0.001444314f, -0.002022405f,  0.002617797f,  0.005494489f,  0.348067701f,  0.523565352f,  0.132003352f, -0.015009303f,  0.006142366f, -0.003314866f,  0.002067706f, -0.001410705f,  0.001023059f },
    /* Phase: -0.781 */    { -0.000459261f,  0.000912415f, -0.001210346f,  0.001672260f, -0.002415403f,  0.003472385f,  0.001592729f,  0.334007114f,  0.529561043f,  0.143767238f, -0.015658984f,  0.006487624f, -0.003523388f,  0.002207060f, -0.001510418f,  0.001097959f },
    /* Phase: -0.812 */    { -0.000499215f,  0.001007064f, -0.001344463f,  0.001877412f, -0.002769954f,  0.004245280f, -0.001877408f,  0.319834918f,  0.534800887f,  0.155905098f, -0.016148042f,  0.006776563f, -0.003701883f,  0.002327534f, -0.001597104f,  0.001163309f },
    /* Phase: -0.844 */    { -0.000534241f,  0.001090132f, -0.001462433f,  0.002058389f, -0.003083922f,  0.004932873f, -0.004930481f,  0.305593669f,  0.539266586f,  0.168393046f, -0.016455622f,  0.007003459f, -0.003847540f,  0.002427438f, -0.001669629f,  0.001218291f },
    /* Phase: -0.875 */    { -0.000564085f,  0.001161030f, -0.001563469f,  0.002214082f, -0.003355641f,  0.005532583f, -0.007582299f,  0.291325331f,  0.542942405f,  0.181205109f, -0.016560614f,  0.007162931f, -0.003957781f,  0.002505239f, -0.001726975f,  0.001262179f },
    /* Phase: -0.906 */    { -0.000588547f,  0.001219301f, -0.001646963f,  0.002343653f, -0.003583910f,  0.006042823f, -0.009849798f,  0.277071148f,  0.545815408f,  0.194313258f, -0.016441761f,  0.007250012f, -0.004030289f,  0.002559584f, -0.001768247f,  0.001294339f },
    /* Phase: -0.938 */    { -0.000607482f,  0.001264614f, -0.001712488f,  0.002446538f, -0.003767987f,  0.006462957f, -0.011750909f,  0.262871474f,  0.547875464f,  0.207687557f, -0.016077779f,  0.007260215f, -0.004063041f,  0.002589311f, -0.001792693f,  0.001314241f },
    /* Phase: -0.969 */    { -0.000620802f,  0.001296770f, -0.001759801f,  0.002522443f, -0.003907583f,  0.006793251f, -0.013304434f,  0.248765543f,  0.549115419f,  0.221296206f, -0.015447486f,  0.007189595f, -0.004054342f,  0.002593471f, -0.001799706f,  0.001321462f }
};

// Public methods ------------------------------------------------------------

void Osc::disable() {
    mDisabled = true;
}

bool Osc::disabled() {
    return mDisabled;
}

uint16_t Osc::frequency() {
    return mFrequency;
}

void Osc::generate(float buf[], size_t nsamples) {
    
    if (mDisabled || mDeltaBuf.size() == 0 || mFrequency > mNyquist) {
        // output silence because:
        //  * oscillator is disabled OR
        //  * waveform is flat OR
        //  * frequency is too high
        std::fill_n(buf, nsamples, 0.0f);
        run(nsamples);
    } else {

        if (mRegenPeriod) {
            fillPeriod();
            mRegenPeriod = false;
        }

        size_t remaining = nsamples;

        // copy from phase to end of period

        auto pbegin = mPeriodBuf.begin();
        auto pend = mPeriodBuf.end();

        float *dest = buf;
        size_t periodsize = mPeriodBuf.size();
        size_t toCopy = std::min(remaining, periodsize - mPeriodOffset);
        std::copy_n(pbegin + mPeriodOffset, toCopy, dest);

        dest += toCopy;
        remaining -= toCopy;
        mPeriodOffset += toCopy;

        while (remaining >= periodsize) {
            std::copy(pbegin, pend, dest);
            dest += periodsize;
            remaining -= periodsize;
        }

        if (mPeriodOffset == periodsize) {
            std::copy(pbegin, pbegin + remaining, dest);
            mPeriodOffset = remaining;
        }

    }

}

float Osc::outputFrequency() {
    // period of the oscilator is (2048 - mFrequency) * multiplier * waveformSize
    // example ranges (multiplier, waveformSize)
    // PulseOsc: (4, 8):    64 Hz - 131,072 Hz
    // WaveOsc: (2, 32):    32 Hz - 65,536 Hz
    return Gbs::CLOCK_SPEED / ((2048 - mFrequency) * mMultiplier * mWaveformSize);
}

void Osc::reset() {
    mPeriodOffset = 0;
    mDisabled = false;
}

void Osc::run(size_t nsamples) {
    if (mRegenPeriod) {
        fillPeriod();
        mRegenPeriod = false;
    }

    mPeriodOffset = (mPeriodOffset + nsamples) % mPeriodBuf.size();
}

void Osc::setFrequency(uint16_t frequency) {
    if (frequency != mFrequency) {
        mFrequency = frequency;
        mRegenPeriod = true;
    }
}

// protected methods ---------------------------------------------------------


Osc::Osc(float samplingRate, size_t multiplier, size_t waveformSize) :
    mMultiplier(multiplier),
    mWaveformSize(waveformSize),
    mFactor(samplingRate / Gbs::CLOCK_SPEED),
    mFrequency(Gbs::DEFAULT_FREQUENCY),
    mDeltaBuf(),
    mInitialVolume(0.0f),
    mRegenPeriod(true),
    mDisabled(false),
    mPeriodBufSize(PERIOD_BUFFER_SIZE_DEFAULT),
    mPeriodBuf(),
    mPeriodOffset(0)
{
    // assert that waveform size is a power of 2
    assert((mWaveformSize & (mWaveformSize - 1)) == 0);

    float nyquist = samplingRate * 0.5f;
    mNyquist = static_cast<uint16_t>(2048 - Gbs::CLOCK_SPEED / (nyquist * multiplier * waveformSize));

}


void Osc::fillPeriod() {

    // TODO: determine best fitting LSB from a fixed period buffer size

    // LSB for quantizing the frequency
    // PulseOsc: 8 * 1/128 -> 1/16, 16 max unique periods
    // WaveOsc:  32 * 1/128 -> 1/4, 4 max unique periods
    // lowering the LSB lowers the maximum size of the period buffer but
    // increases frequency error
    //
    // we quantize the timing variables so that we limit the number of max unique
    // periods. A unique period has a unique set of phases for each transition.
    // Doing so we can sample a buffer that loops seamlessly, which we can
    // sample from to fill any sized buffer.

    constexpr float LSB = 1 / 128.0f;

    // spd : samples per delta transition
    float spd = (2048 - mFrequency) * mMultiplier * mFactor;
    // quantize spd
    spd = LSB * floorf((spd / LSB) + 0.5f);
    // spp : samples per period
    float spp = spd * mWaveformSize;

    unsigned nperiods = static_cast<unsigned>(1.0f / (LSB * mWaveformSize));
    // spp is casted to double to prevent stupid arithmetic overflow warnings
    size_t bufsize = static_cast<size_t>(nperiods * static_cast<double>(spp));
    assert((nperiods * spp) - bufsize == 0);

    // adjust phase proportionally to new buffer size
    if (mPeriodBuf.size() != 0) {
        mPeriodOffset = (mPeriodOffset * bufsize) / mPeriodBuf.size();
    } else {
        mPeriodOffset = 0;
    }
    mPeriodBuf.resize(bufsize);
    std::fill(mPeriodBuf.begin(), mPeriodBuf.end(), 0.0f);

    if (mFrequency <= mNyquist && mDeltaBuf.size() > 0) {

        // wraparound buffer, used to replace the start of the period buf so that
        // the entire loops seamlessly.
        float wraparound[STEP_WIDTH - 1];
        // make sure it is zero'd
        std::fill_n(wraparound, STEP_WIDTH - 1, 0.0f);
        float *periodBufData = mPeriodBuf.data();


        for (auto &delta : mDeltaBuf) {
            float position = delta.location * spd;
            float change = delta.change;

            for (size_t p = 0; p != nperiods; ++p) {

                // determine step set
                float positionWhole;
                float positionFract = modff(position, &positionWhole);
                // the step set chosen is determined by the fractional part of position
                float phase = positionFract * STEP_PHASES;
                const float *stepset = STEP_TABLE[static_cast<size_t>(phase)];

                // calculate indexing of the step
                size_t positionIndex = static_cast<size_t>(positionWhole);
                size_t endIndex = positionIndex + STEP_WIDTH;
                size_t stepEnd; // how much of the step that gets copied, remainder goes to wraparound
                size_t center1 = positionIndex + STEP_CENTER - 1;
                size_t center2 = positionIndex + STEP_CENTER;
                if (endIndex > bufsize) {
                    // at the end of buffer
                    stepEnd = bufsize - positionIndex;
                } else {
                    // plenty of room
                    stepEnd = STEP_WIDTH;
                }

                // add the step to the period buffer at position
                float *dest = periodBufData + positionIndex;
                // step must sum to the amount it changes by, keep track of precision error
                float error = change;
                for (size_t i = 0; i != stepEnd; ++i) {
                    float sample = change * stepset[i];
                    error -= sample;
                    *dest++ += sample;
                }

                // add the step to wraparound, only when endIndex > bufsize
                dest = wraparound;
                for (size_t i = stepEnd; i != STEP_WIDTH; ++i) {
                    float sample = change * stepset[i];
                    error -= sample;
                    *dest++ += sample;
                }

                // split the error between the two centers, equally
                float halferror = error * 0.5f;
                if (center1 >= bufsize) {
                    // center is in wraparound
                    center1 -= bufsize;
                }
                if (center2 >= bufsize) {
                    // center is in wraparound
                    center2 -= bufsize;
                }
                
                mPeriodBuf[center1] += halferror;
                mPeriodBuf[center2] += halferror;
                

                // advance position to the next period
                position += spp;
            }
        }

        // add differences from start of period to wraparound
        for (size_t i = 0; i != STEP_WIDTH - 1; ++i) {
            wraparound[i] += mPeriodBuf[i];
        }


        // do the running sum

        float previous = mInitialVolume;
        for (size_t i = 0; i != bufsize; ++i) {
            float cur = mPeriodBuf[i] + previous;
            mPeriodBuf[i] = cur;
            previous = cur;
        }

        // running sum the wraparound buffer, moving each sample to start of period
        for (size_t i = 0; i != STEP_WIDTH - 1; ++i) {
            float cur = wraparound[i] + previous;
            mPeriodBuf[i] = cur;
            previous = cur;
        }

        // OPTIONAL: shift by the period by STEP_CENTER so that transitions are
        //           centered at the time they occur.
        //
        //     /----      /----
        // ---/       ---/
        // ^              ^
        // before         after
    }
}

std::vector<float>& Osc::period() {
    return mPeriodBuf;
}

}