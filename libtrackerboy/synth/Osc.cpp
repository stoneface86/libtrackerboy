
#include "trackerboy/synth/Osc.hpp"
#include "trackerboy/gbs.hpp"

#include <algorithm>
#include <cassert>
#include <cmath>
#include <cstddef>


namespace trackerboy {

const float Osc::STEP_TABLE[Osc::STEP_PHASES][Osc::STEP_WIDTH] = {
    // this table was generated by genstep.py
    // genstep.py 48000 64 32 16
    /* Phase:  0.000 */    {  0.000687230f, -0.001788836f,  0.002571344f, -0.004002845f,  0.007034825f, -0.014529911f,  0.235105664f,  0.550034881f,  0.235295504f, -0.014529911f,  0.007034825f, -0.004002845f,  0.002571344f, -0.001788836f,  0.001315700f, -0.001008166f },
    /* Phase: -0.031 */    {  0.000690953f, -0.001799706f,  0.002593471f, -0.004054342f,  0.007189595f, -0.015447486f,  0.221296206f,  0.549617767f,  0.249267891f, -0.013304434f,  0.006793251f, -0.003907583f,  0.002522443f, -0.001759801f,  0.001296770f, -0.000994989f },
    /* Phase: -0.062 */    {  0.000687247f, -0.001792693f,  0.002589311f, -0.004063041f,  0.007260215f, -0.016077779f,  0.207687557f,  0.548371136f,  0.263367116f, -0.011750909f,  0.006462957f, -0.003767987f,  0.002446538f, -0.001712488f,  0.001264614f, -0.000971783f },
    /* Phase: -0.094 */    {  0.000676291f, -0.001768247f,  0.002559584f, -0.004030289f,  0.007250012f, -0.016441761f,  0.194313258f,  0.546299458f,  0.277555197f, -0.009849798f,  0.006042823f, -0.003583910f,  0.002343653f, -0.001646963f,  0.001219301f, -0.000938614f },
    /* Phase: -0.125 */    {  0.000658330f, -0.001726975f,  0.002505239f, -0.003957781f,  0.007162931f, -0.016560614f,  0.181205109f,  0.543410063f,  0.291793019f, -0.007582299f,  0.005532583f, -0.003355641f,  0.002214082f, -0.001563469f,  0.001161030f, -0.000895644f },
    /* Phase: -0.156 */    {  0.000633671f, -0.001669629f,  0.002427438f, -0.003847540f,  0.007003459f, -0.016455622f,  0.168393046f,  0.539713323f,  0.306040436f, -0.004930481f,  0.004932873f, -0.003083922f,  0.002058389f, -0.001462433f,  0.001090132f, -0.000843135f },
    /* Phase: -0.188 */    {  0.000602678f, -0.001597104f,  0.002327534f, -0.003701883f,  0.006776563f, -0.016148042f,  0.155905098f,  0.535222352f,  0.320256352f, -0.001877408f,  0.004245280f, -0.002769954f,  0.001877412f, -0.001344463f,  0.001007064f, -0.000781445f },
    /* Phase: -0.219 */    {  0.000565771f, -0.001510418f,  0.002207060f, -0.003523388f,  0.006487624f, -0.015658984f,  0.143767238f,  0.529953003f,  0.334399074f,  0.001592729f,  0.003472385f, -0.002415403f,  0.001672260f, -0.001210346f,  0.000912415f, -0.000711029f },
    /* Phase: -0.250 */    {  0.000523418f, -0.001410705f,  0.002067706f, -0.003314866f,  0.006142366f, -0.015009303f,  0.132003352f,  0.523923993f,  0.348426402f,  0.005494489f,  0.002617797f, -0.002022405f,  0.001444314f, -0.001061045f,  0.000806895f, -0.000632432f },
    /* Phase: -0.281 */    {  0.000476130f, -0.001299199f,  0.001911300f, -0.003079323f,  0.005746786f, -0.014219489f,  0.120635159f,  0.517156661f,  0.362295717f,  0.009841058f,  0.001686188f, -0.001593562f,  0.001195220f, -0.000897697f,  0.000691335f, -0.000546291f },
    /* Phase: -0.312 */    {  0.000424455f, -0.001177223f,  0.001739787f, -0.002819927f,  0.005307097f, -0.013309569f,  0.109682165f,  0.509674728f,  0.375964344f,  0.014644136f,  0.000683316f, -0.001131937f,  0.000926879f, -0.000721599f,  0.000566681f, -0.000453325f },
    /* Phase: -0.344 */    {  0.000368975f, -0.001046172f,  0.001555211f, -0.002539977f,  0.004829650f, -0.012299008f,  0.099161617f,  0.501504421f,  0.389389575f,  0.019913817f, -0.000383957f, -0.000641038f,  0.000641436f, -0.000534207f,  0.000433985f, -0.000354332f },
    /* Phase: -0.375 */    {  0.000310296f, -0.000907499f,  0.001359686f, -0.002242860f,  0.004320879f, -0.011206622f,  0.089088507f,  0.492674291f,  0.402528942f,  0.025658498f, -0.001507654f, -0.000124808f,  0.000341273f, -0.000337120f,  0.000294399f, -0.000250182f },
    /* Phase: -0.406 */    {  0.000249044f, -0.000762702f,  0.001155383f, -0.001932025f,  0.003787235f, -0.010050495f,  0.079475522f,  0.483214915f,  0.415340394f,  0.031884756f, -0.002678678f,  0.000412395f,  0.000028983f, -0.000132070f,  0.000149166f, -0.000141811f },
    /* Phase: -0.438 */    {  0.000185858f, -0.000613306f,  0.000944502f, -0.001610945f,  0.003235131f, -0.008847907f,  0.070333056f,  0.473158956f,  0.427782506f,  0.038597289f, -0.003886812f,  0.000965828f, -0.000292641f,  0.000079091f, -0.000000393f, -0.000030211f },
    /* Phase: -0.469 */    {  0.000121383f, -0.000460850f,  0.000729251f, -0.001283082f,  0.002670879f, -0.007615265f,  0.061669238f,  0.462540925f,  0.439814597f,  0.045798801f, -0.005120736f,  0.001530387f, -0.000620630f,  0.000294405f, -0.000152887f,  0.000083578f },
    /* Phase: -0.500 */    {  0.000056266f, -0.000306870f,  0.000511831f, -0.000951860f,  0.002100643f, -0.006368043f,  0.053489938f,  0.451397002f,  0.451397002f,  0.053489938f, -0.006368043f,  0.002100643f, -0.000951860f,  0.000511831f, -0.000306870f,  0.000198474f },
    /* Phase: -0.531 */    { -0.000008851f, -0.000152887f,  0.000294405f, -0.000620630f,  0.001530387f, -0.005120736f,  0.045798801f,  0.439764827f,  0.462491155f,  0.061669238f, -0.007615265f,  0.002670879f, -0.001283082f,  0.000729251f, -0.000460850f,  0.000313368f },
    /* Phase: -0.562 */    { -0.000073340f, -0.000000393f,  0.000079091f, -0.000292641f,  0.000965828f, -0.003886812f,  0.038597289f,  0.427683443f,  0.473059893f,  0.070333056f, -0.008847907f,  0.003235131f, -0.001610945f,  0.000944502f, -0.000613306f,  0.000427133f },
    /* Phase: -0.594 */    { -0.000136589f,  0.000149166f, -0.000132070f,  0.000028983f,  0.000412395f, -0.002678678f,  0.031884756f,  0.415192991f,  0.483067513f,  0.079475522f, -0.010050495f,  0.003787235f, -0.001932025f,  0.001155383f, -0.000762702f,  0.000538629f },
    /* Phase: -0.625 */    { -0.000198008f,  0.000294399f, -0.000337120f,  0.000341273f, -0.000124808f, -0.001507654f,  0.025658498f,  0.402334630f,  0.492479980f,  0.089088507f, -0.011206622f,  0.004320879f, -0.002242860f,  0.001359686f, -0.000907499f,  0.000646722f },
    /* Phase: -0.656 */    { -0.000257037f,  0.000433985f, -0.000534207f,  0.000641436f, -0.000641038f, -0.000383957f,  0.019913817f,  0.389150262f,  0.501265109f,  0.099161617f, -0.012299008f,  0.004829650f, -0.002539977f,  0.001555211f, -0.001046172f,  0.000750291f },
    /* Phase: -0.688 */    { -0.000313146f,  0.000566681f, -0.000721599f,  0.000926879f, -0.001131937f,  0.000683316f,  0.014644136f,  0.375682354f,  0.509392738f,  0.109682165f, -0.013309569f,  0.005307097f, -0.002819927f,  0.001739787f, -0.001177223f,  0.000848237f },
    /* Phase: -0.719 */    { -0.000365846f,  0.000691335f, -0.000897697f,  0.001195220f, -0.001593562f,  0.001686188f,  0.009841058f,  0.361973822f,  0.516834736f,  0.120635159f, -0.014219489f,  0.005746786f, -0.003079323f,  0.001911300f, -0.001299199f,  0.000939498f },
    /* Phase: -0.750 */    { -0.000414685f,  0.000806895f, -0.001061045f,  0.001444314f, -0.002022405f,  0.002617797f,  0.005494489f,  0.348067701f,  0.523565352f,  0.132003352f, -0.015009303f,  0.006142366f, -0.003314866f,  0.002067706f, -0.001410705f,  0.001023059f },
    /* Phase: -0.781 */    { -0.000459261f,  0.000912415f, -0.001210346f,  0.001672260f, -0.002415403f,  0.003472385f,  0.001592729f,  0.334007114f,  0.529561043f,  0.143767238f, -0.015658984f,  0.006487624f, -0.003523388f,  0.002207060f, -0.001510418f,  0.001097959f },
    /* Phase: -0.812 */    { -0.000499215f,  0.001007064f, -0.001344463f,  0.001877412f, -0.002769954f,  0.004245280f, -0.001877408f,  0.319834918f,  0.534800887f,  0.155905098f, -0.016148042f,  0.006776563f, -0.003701883f,  0.002327534f, -0.001597104f,  0.001163309f },
    /* Phase: -0.844 */    { -0.000534241f,  0.001090132f, -0.001462433f,  0.002058389f, -0.003083922f,  0.004932873f, -0.004930481f,  0.305593669f,  0.539266586f,  0.168393046f, -0.016455622f,  0.007003459f, -0.003847540f,  0.002427438f, -0.001669629f,  0.001218291f },
    /* Phase: -0.875 */    { -0.000564085f,  0.001161030f, -0.001563469f,  0.002214082f, -0.003355641f,  0.005532583f, -0.007582299f,  0.291325331f,  0.542942405f,  0.181205109f, -0.016560614f,  0.007162931f, -0.003957781f,  0.002505239f, -0.001726975f,  0.001262179f },
    /* Phase: -0.906 */    { -0.000588547f,  0.001219301f, -0.001646963f,  0.002343653f, -0.003583910f,  0.006042823f, -0.009849798f,  0.277071148f,  0.545815408f,  0.194313258f, -0.016441761f,  0.007250012f, -0.004030289f,  0.002559584f, -0.001768247f,  0.001294339f },
    /* Phase: -0.938 */    { -0.000607482f,  0.001264614f, -0.001712488f,  0.002446538f, -0.003767987f,  0.006462957f, -0.011750909f,  0.262871474f,  0.547875464f,  0.207687557f, -0.016077779f,  0.007260215f, -0.004063041f,  0.002589311f, -0.001792693f,  0.001314241f },
    /* Phase: -0.969 */    { -0.000620802f,  0.001296770f, -0.001759801f,  0.002522443f, -0.003907583f,  0.006793251f, -0.013304434f,  0.248765543f,  0.549115419f,  0.221296206f, -0.015447486f,  0.007189595f, -0.004054342f,  0.002593471f, -0.001799706f,  0.001321462f }
};

// Public methods ------------------------------------------------------------

void Osc::copyPeriod(std::vector<float> &buf) {
    if (mRegenPeriod) {
        fillPeriod();
        mRegenPeriod = false;
    }

    buf.resize(mPeriodBuf.size());
    std::copy(mPeriodBuf.begin(), mPeriodBuf.end(), buf.begin());
}

void Osc::disable() {
    mDisabled = true;
}

bool Osc::disabled() {
    return mDisabled;
}

uint16_t Osc::frequency() {
    return mFrequency;
}

void Osc::generate(float buf[], size_t nsamples) {
    
    if (mDisabled || mDeltaBuf.size() == 0 || mFrequency > mNyquist) {
        // output silence because:
        //  * oscillator is disabled OR
        //  * waveform is flat OR
        //  * frequency is too high
        std::fill_n(buf, nsamples, 0.0f);
        run(nsamples);
    } else {

        if (mRegenPeriod) {
            fillPeriod();
            mRegenPeriod = false;
        }

        size_t remaining = nsamples;

        // copy from phase to end of period

        auto pbegin = mPeriodBuf.begin();
        auto pend = mPeriodBuf.end();

        float *dest = buf;
        size_t periodsize = mPeriodBuf.size();
        size_t toCopy = std::min(remaining, periodsize - mPeriodOffset);
        std::copy_n(pbegin + mPeriodOffset, toCopy, dest);

        dest += toCopy;
        remaining -= toCopy;
        mPeriodOffset += toCopy;

        while (remaining >= periodsize) {
            std::copy(pbegin, pend, dest);
            dest += periodsize;
            remaining -= periodsize;
        }

        if (mPeriodOffset == periodsize) {
            std::copy(pbegin, pbegin + remaining, dest);
            mPeriodOffset = remaining;
        }

    }

}

float Osc::outputFrequency() {
    // period of the oscilator is (2048 - mFrequency) * multiplier * waveformSize
    // example ranges (multiplier, waveformSize)
    // PulseOsc: (4, 8):    64 Hz - 131,072 Hz
    // WaveOsc: (2, 32):    32 Hz - 65,536 Hz
    return Gbs::CLOCK_SPEED / ((2048 - mFrequency) * mMultiplier * mWaveformSize);
}

void Osc::reset() {
    mPeriodOffset = 0;
    mDisabled = false;
}

void Osc::run(size_t nsamples) {
    if (mRegenPeriod) {
        fillPeriod();
        mRegenPeriod = false;
    }

    mPeriodOffset = (mPeriodOffset + nsamples) % mPeriodBuf.size();
}

void Osc::setFrequency(uint16_t frequency) {
    if (frequency != mFrequency) {
        mFrequency = frequency;
        mRegenPeriod = true;
    }
}

void Osc::setBufferSize(unsigned milleseconds) {
    if (milleseconds < mMinBufferSize) {
        milleseconds = mMinBufferSize;
    }
    mPeriodMaxSize = static_cast<size_t>(mSamplingRate * milleseconds / 1000);
    mRegenPeriod = true;
}

// protected methods ---------------------------------------------------------


Osc::Osc(float samplingRate, size_t multiplier, size_t waveformSize) :
    mMultiplier(multiplier),
    mWaveformSize(waveformSize),
    mSamplingRate(samplingRate),
    mFrequency(Gbs::DEFAULT_FREQUENCY),
    mDeltaBuf(),
    mInitialVolume(0.0f),
    mRegenPeriod(true),
    mDisabled(false),
    mPeriodMaxSize(0),
    mPeriodBuf(),
    mPeriodOffset(0)
{
    // assert that waveform size is a power of 2
    assert((mWaveformSize & (mWaveformSize - 1)) == 0);

    // the minimum buffer size is the period of the lowest frequency (f = 0, so 2048 - 0 = 2048)
    float minimum = ceilf((2048 * mMultiplier * mWaveformSize * 1000) / Gbs::CLOCK_SPEED);
    mMinBufferSize = static_cast<unsigned>(minimum);

    float nyquist = samplingRate * 0.5f;
    mNyquist = static_cast<uint16_t>(2048 - Gbs::CLOCK_SPEED / (nyquist * multiplier * waveformSize));
    setBufferSize(PERIOD_BUFFER_SIZE_DEFAULT);
}


void Osc::fillPeriod() {

    // This method fills the period buffer with multiple periods, such that they
    // can be looped seamlessly, as if an infinite signal could be generated using
    // this buffer alone. In order to do this, the time of all periods must result
    // in a whole number. Since our calculations involve dividing by the clock rate,
    // 4194304, we can simply use 4194304 total periods to get a whole number. However,
    // this would require a really large buffer, so instead we use quantization so
    // that the actual divisor is much smaller. By quantizing we reduce this fraction, at a slight
    // cost to accuracy due to roundoff error. Accuracy can be controlled by the size of the
    // buffer, (larger = more accurate).
    //
    // So the contents of the period buffer is a sequence of periods, with a subset of these
    // being unique. A unique period has a unique set of phases for its transitions.
    //
    // Example:
    // 50% square wave with frequency f = 1923 (C-6), sampling rate is 44100 Hz, buffer size = 100ms
    // determine timing variables // NOTE: Q format, Q42.22
    // qSpd = (2048 - 1923) * 4 * 44100 = 22050000 (~5.257129669)
    // qSpp = 22050000 * 8 = 176400000 (~42.05703735)
    //
    // determine periods (4410 is 100ms of 44100) // NOTE: periods is not in Q format!
    // periods = (4194304 * 4410) / 176400000 = 104.8576 = 104
    // 2^floor(log2(104)) = 64
    // so we will have 64 periods total in the buffer
    //
    // now we quantize qSpd with LSB = 1 / (64 * 8) = 1/512
    // 512 = 2^9 so we need to shift the mask by 22 - 9 = 13
    //
    //   000101.0100000111010011010000
    // + 000000.0000000001000000000000  // add 1 << (shift - 1)
    // -------------------------------
    //   000101.0100001000010011010000
    // & 111111.1111111110000000000000  // and -1 << (shift)
    // -------------------------------
    //   000101.0100001000000000000000
    //
    // so our quantized qSpd is now 22052864 or 5.2578125
    // recalculate qSpp with the quantized qSpd
    // qSpp = 22052864 * 8 = 176422912 or 42.0625 (.0625 is 1/16 so we have 16 unique periods)
    //
    // now determine the total time of the buffer (or the actual number of samples that is utilized)
    // qTime = 176422912 * 64 = 11291066368 or 2692.0
    // NOTE: qTime should be a whole number! If it isn't our calculation is wrong.
    //
    // Conclusion
    // the period buffer is 2692 samples long, with 64 periods and 16 unique periods.
    // Utilization of the buffer is 2692/4410 or 61%, utilization will always be > 50% of the maximum
    // We can compare the accuracy of the frequency through the quantized and non-quantized period times
    // (non-quantized) spp = 42.05703735, frequency = 44100 / 42.05603735 = 1048.576    Hz
    //     (quantized) spp = 42.0625,     frequency = 44100 / 42.0625     = 1048.439822 Hz
    //
    // since the clock speed is 2^22, we can use fixed point, Q42.22 for calculations
    // instead of floating point. Variables that are prefixed with q are in Q42.22 format

    // diving this value by 4194304 gives us the number of samples per delta transition
    // spd is the length of time, in samples, for a transition in the waveform
    uint64_t qSpd = (2048 - mFrequency) * mMultiplier * static_cast<uint64_t>(mSamplingRate);
    // spp is the length of time for an entire period
    uint64_t qSpp = qSpd * mWaveformSize;

    // determine the number of periods we can fit in our buffer
    uint64_t periods = (mPeriodMaxSize * 4194304) / qSpp;
    assert(periods > 0);

    // reduce this to the previous power of 2 for quantizing
    // also equal to 2^floor(log2(num))
    periods |= periods >> 1;
    periods |= periods >> 2;
    periods |= periods >> 4;
    periods |= periods >> 8;
    periods |= periods >> 16;
    periods |= periods >> 32;
    periods -= periods >> 1;

    // shift = log2(periods)
    int shift = 0;
    uint64_t temp = periods * mWaveformSize;
    while (temp != 1) {
        temp >>= 1;
        shift++;
    }

    shift = 22 - shift;
    assert(shift > 0);

    // quantize
    qSpd += static_cast<uint64_t>(1) << (shift - 1);
    qSpd &= static_cast<uint64_t>(-1) << shift;
    qSpp = qSpd * mWaveformSize;

    // total time of the period buffer from our quantized spd
    uint64_t qTime = qSpp * periods;
    // the fractional part of qTime must equal 0 (whole number)
    assert((qTime & (4194304 - 1)) == 0);
    size_t bufsize = qTime >> 22;
    // bufsize must not exceed our maximum
    assert(bufsize <= mPeriodMaxSize);

    // adjust phase proportionally to new buffer size
    if (mPeriodBuf.size() != 0) {
        mPeriodOffset = (mPeriodOffset * bufsize) / mPeriodBuf.size();
    } else {
        mPeriodOffset = 0;
    }
    mPeriodBuf.resize(bufsize);
    std::fill(mPeriodBuf.begin(), mPeriodBuf.end(), 0.0f);

    if (mFrequency <= mNyquist && mDeltaBuf.size() > 0) {

        // wraparound buffer, used to replace the start of the period buf so that
        // the entire loops seamlessly.
        float wraparound[STEP_WIDTH - 1];
        // make sure it is zero'd
        std::fill_n(wraparound, STEP_WIDTH - 1, 0.0f);
        float *periodBufData = mPeriodBuf.data();


        for (auto &delta : mDeltaBuf) {
            uint64_t qPosition = delta.location * qSpd;
            float change = delta.change;

            for (size_t p = 0; p != periods; ++p) {

                // determine step set
                // get the integral part of qPosition
                uint64_t qPositionWhole = qPosition >> 22;
                // get the fractional part of qPosition
                uint64_t qPositionFract = qPosition & ((1 << 22) - 1);
                
                // the step set chosen is determined by the fractional part of position
                const float *stepset = STEP_TABLE[(qPositionFract * STEP_PHASES) >> 22];

                // calculate indexing of the step
                size_t positionIndex = static_cast<size_t>(qPositionWhole);
                size_t endIndex = positionIndex + STEP_WIDTH;
                size_t stepEnd; // how much of the step that gets copied, remainder goes to wraparound
                size_t center2 = positionIndex + STEP_CENTER;
                size_t center1 = center2 - 1;

                if (endIndex > bufsize) {
                    // at the end of buffer
                    stepEnd = bufsize - positionIndex;
                } else {
                    // plenty of room
                    stepEnd = STEP_WIDTH;
                }

                // add the step to the period buffer at position
                float *dest = periodBufData + positionIndex;
                // step must sum to the amount it changes by, keep track of precision error
                float error = change;
                for (size_t i = 0; i != stepEnd; ++i) {
                    float sample = change * stepset[i];
                    error -= sample;
                    *dest++ += sample;
                }

                // add the step to wraparound, only when endIndex > bufsize
                dest = wraparound;
                for (size_t i = stepEnd; i != STEP_WIDTH; ++i) {
                    float sample = change * stepset[i];
                    error -= sample;
                    *dest++ += sample;
                }

                // split the error between the two centers, equally
                float halferror = error * 0.5f;
                if (center1 >= bufsize) {
                    // center is in wraparound
                    center1 -= bufsize;
                }
                if (center2 >= bufsize) {
                    // center is in wraparound
                    center2 -= bufsize;
                }
                
                mPeriodBuf[center1] += halferror;
                mPeriodBuf[center2] += halferror;
                

                // advance position to the next period
                qPosition += qSpp;
            }
        }

        // add differences from start of period to wraparound
        for (size_t i = 0; i != STEP_WIDTH - 1; ++i) {
            wraparound[i] += mPeriodBuf[i];
        }


        // do the running sum

        float previous = mInitialVolume;
        for (size_t i = 0; i != bufsize; ++i) {
            float cur = mPeriodBuf[i] + previous;
            mPeriodBuf[i] = cur;
            previous = cur;
        }

        // running sum the wraparound buffer, moving each sample to start of period
        for (size_t i = 0; i != STEP_WIDTH - 1; ++i) {
            float cur = wraparound[i] + previous;
            mPeriodBuf[i] = cur;
            previous = cur;
        }
    }
}

}
