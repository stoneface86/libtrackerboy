
#include "trackerboy/synth/Osc.hpp"
#include "trackerboy/gbs.hpp"
#include "./sampletable.hpp"

#include <algorithm>
#include <cassert>
#include <cmath>
#include <cstddef>

//
// TODO: replace PulseChannel and WaveChannel step methods with this
//

namespace {

// Circular iterator, iterator will go back to the start after exceeding
// its given range. This isn't a real iterator as iterators are not
// meant to be cyclic, so its uses are limited. However, it should work with
// fill_n and copy_n functions (which is what we want).
//

template <typename T>
class CircularIterator {

public:
    using self_type = CircularIterator<T>;
    using value_type = T;
    using reference = T&;
    using pointer = T*;
    using iterator_category = std::forward_iterator_tag;
    using difference_type = int;

    CircularIterator() = default;
    CircularIterator(pointer begin, pointer cur, pointer end) :
        mBegin(begin),
        mCurrent(cur),
        mEnd(end),
        mRange(end - begin)
    {
    }

    CircularIterator(pointer start, size_t endIndex) :
        mBegin(start),
        mCurrent(start),
        mEnd(start + endIndex),
        mRange(endIndex)
    {
    }

    CircularIterator(const self_type &iter) :
        mBegin(iter.mBegin),
        mCurrent(iter.mCurrent),
        mEnd(iter.mEnd),
        mRange(iter.mRange)
    {
    }

    ~CircularIterator() {

    }

    self_type operator++() {
        if (++mCurrent == mEnd) {
            mCurrent = mBegin;
        }
        return *this;
    }

    self_type operator++(int junk) {
        (void)junk;
        self_type i = *this;
        if (++mCurrent == mEnd) {
            mCurrent = mBegin;
        }
        return i;
    }

    self_type operator--() {
        if (mCurrent-- == mBegin) {
            mCurrent = mEnd - 1;
        }
        return *this;
    }

    self_type operator--(int junk) {
        (void)junk;
        self_type i = *this;
        if (mCurrent-- == mBegin) {
            mCurrent = mEnd - 1;
        }
        return i;
    }

    self_type& operator+=(const size_t rhs) {
        mCurrent += rhs;
        ptrdiff_t diff = mEnd - mCurrent;
        if (diff <= 0) {
            mCurrent = mStart + (abs(diff) % mRange);
        }
    }

    self_type& operator-=(const size_t rhs) {
        mCurrent -= rhs;
        ptrdiff_t diff = mCurrent - mStart;
        if (diff < 0) {
            mCurrent = mEnd - (abs(diff) % mRange);
        }
    }

    reference operator*() {
        return *mCurrent;
    }

    pointer operator->() {
        return mCurrent;
    }

    reference operator[](int index) {
        size_t actual;
        if (index < 0) {
            actual = mRange - (abs(index) % mRange);
        } else {
            actual = index % mRange;
        }
        return mBegin[actual];
    }

    void setOffset(size_t offset) {
        mCurrent = mBegin + (offset % mRange);
    }

    void setRange(pointer begin, pointer end) {
        mBegin = begin;
        mCurrent = begin;
        mEnd = end;
        mRange = end - begin;
    }

    void setRange(pointer begin, size_t range) {
        mBegin = begin;
        mCurrent = begin;
        mEnd = begin + range;
        mRange = range;
    }

private:
    pointer mBegin;
    pointer mCurrent;
    pointer mEnd;
    size_t mRange;
};



}


namespace trackerboy {

// Step table
// this table contains sets of bandlimited steps
// each set has a different phase (0 to -1). First set has a phase of -1/(SINC_PHASES+1)
// and the last set has a phase of -(SINC_PHASES)/(SINC_PHASES+1)
// see https://www.desmos.com/calculator/w0rh8oarmu for how these values were chosen.
// When generating a band-limited step, the fractional part of the sample counter is
// used to pick the set.
//
// using this we can create bandlimited steps by multiplying each value in a step by
// the delta change.


const float Osc::STEP_TABLE[Osc::STEP_PHASES][Osc::STEP_COUNT] = {
    // yes I know these literals would require doubles to fit them
    // table was generated by a script, do not edit manually thank you please
    {   -0.004303837003158535f,    0.0007137016135891098f,   -0.0053012994992589785f,    0.0022061454987318783f,    -0.007778756348595973f,     0.007124082229505179f,     -0.02224327614498844f,        0.976246908587795f,       1.0074497268606946f,       0.9920883394032671f,       1.0022770147576834f,       0.9946549522788071f,       1.0007433070637632f,       0.9956748289686729f,       1.0000160906414242f},
    {   -0.008531922264946775f,    0.0014077671737162244f,    -0.010496052513305232f,    0.0043393048578334575f,    -0.015343248486053533f,     0.013891132215896407f,     -0.04290709314789196f,       0.9510618507184063f,       1.0151888793549417f,       0.9841273498591199f,        1.004621554887291f,       0.9893297249816556f,       1.0015256629432052f,       0.9913831226996714f,       1.0000640741744864f},
    {   -0.012646933834962728f,     0.002076362271411796f,    -0.015539009855857837f,     0.006382342124744382f,    -0.022631211967229156f,     0.020258389733949132f,    -0.061946680193309296f,       0.9245141589337927f,       1.0231602428465032f,        0.976185917173784f,        1.007012818396506f,        0.984071868649364f,       1.0023396619665326f,       0.9871633413645772f,       1.0001430892478285f},
    {   -0.016612878811407956f,    0.0027139851523587284f,    -0.020386763490723353f,     0.008319313867224367f,    -0.029583856236473607f,     0.026187951201824735f,     -0.07932627908684783f,        0.896680351083375f,        1.031301955244785f,       0.9683337855563836f,       1.0094288015635509f,       0.9789285943707313f,       1.0031772063004263f,       0.9830533582556794f,       1.0002517129723354f},
    {   -0.020395402776507254f,    0.0033155088257376363f,      -0.0249981091463548f,      0.01013557738835845f,    -0.036146298142946516f,     0.031646871649387544f,     -0.09501931401523694f,       0.8676436970359085f,       1.0395478061521846f,       0.9606410019676644f,       1.0118464812788956f,       0.9739463627335749f,       1.0040295818289233f,        0.979090125584075f,       1.0003879798108704f},
    {    -0.02396208212375478f,    0.0038762191670779836f,     -0.02933438588163479f,     0.011817885591770182f,    -0.042267956916133505f,     0.036607230074559384f,     -0.10900849975441224f,       0.8374937441339032f,       1.0478275761090845f,       0.9531773517202529f,       1.0142420126162732f,       0.9691704771930201f,       1.0048875430001263f,       0.9753093478786165f,       1.0005494077156383f},
    {     -0.0272826968321981f,     0.004391848758353845f,     -0.03335978988154818f,      0.01335446800379822f,     -0.04790290790245792f,      0.04104615848196874f,      -0.1212858876696101f,        0.806325804625126f,       1.0560674140890935f,       0.9460117895795485f,       1.0165909400802349f,       0.9646446853117296f,       1.0057414058564331f,       0.9717451658246888f,       1.0007330312088993f},
    {   -0.030329481434681574f,     0.004858606249245105f,     -0.03704166001022829f,     0.014735097581835187f,     -0.05301019272553758f,     0.044945835151339285f,     -0.13185284930936547f,       0.7742404085517466f,       1.0641902510673025f,       0.9392118706726663f,       1.0188684208143024f,       0.9604107912748758f,       1.0065811483633402f,       0.9684298532955039f,        1.000935441021463f},
    {    -0.03307735213697084f,     0.005273201065314197f,     -0.04035073291671456f,      0.01595114306110825f,     -0.05755408390993821f,     0.048293442928368686f,     -0.14071999785432232f,       0.7413427257982358f,        1.072116247167945f,       0.9328431855385938f,       1.0210494579038496f,        0.956508283002443f,       1.0073965170593213f,       0.9653935302187233f,       1.0011528298262593f},
    {    -0.03550410827100178f,    0.0056328633314570165f,     -0.04326136577317973f,     0.016995606714928946f,     -0.06150430239802007f,      0.05108109356660423f,     -0.14790704813831307f,       0.7077419611928313f,       1.0797632695976767f,       0.9269688036456866f,       1.0231091417727816f,       0.9529739770735074f,       1.0081771389658392f,       0.9626638937886507f,       1.0013810435321413f},
    {   -0.037590606506031236f,     0.005935358922004932f,     -0.04575172502378802f,     0.017863147524880246f,     -0.06483618678838857f,      0.05330571937342403f,       -0.153442616409748f,       0.6735507267229401f,        1.087047398289284f,       0.9216487296627465f,       1.0250228975543325f,       0.9498416845422699f,       1.0089126376231763f,        0.960265970380077f,       1.0016156375367113f},
    {    -0.03932090649400914f,     0.006178999591915729f,    -0.047803939832062936f,      0.01855008987657751f,     -0.06753081352922637f,       0.0549689336251868f,     -0.15736396144246273f,       0.6388843950612229f,        1.093883455920472f,       0.9169393766974306f,       1.0267667362151804f,       0.9471419005648118f,        1.009592752055297f,       0.9582218903453817f,       1.0018519372770907f},
    {   -0.040682386887727934f,     0.006362648186232334f,    -0.049404219232900344f,      0.01905441801265561f,     -0.06957506770703742f,     0.056076861414552676f,     -0.15971666903339554f,       0.6038604387054983f,       1.1001855587357792f,       0.9128930606111448f,        1.028317507129815f,       0.9449015205701039f,       1.0102074574161934f,       0.9565506876831901f,       1.0020851023648671f},
    {    -0.04166583093987838f,    0.0064857189670565404f,    -0.050542932319369176f,     0.019375756586591096f,     -0.07096166447774699f,      0.05663994277563056f,     -0.16055428233650143f,       0.5685977591113702f,       1.1058676843887496f,       0.9095575193835533f,       1.0296531497396735f,       0.9431435855000955f,       1.0107470860316863f,       0.9552681263563048f,         1.00231019354649f},
    {    -0.04226548116562618f,     0.006548173138336451f,    -0.051214651121352664f,     0.019515337768062593f,      -0.0716891215893413f,      0.05667271009885676f,      -0.1599378808749775f,       0.5332160102412922f,       1.1108442528381834f,       0.9069754613333982f,       1.0307529418898749f,         0.94188705841343f,        1.011202447525057f,       0.9543865548106086f,        1.002522241693683f},
    {   -0.042479062828281865f,    0.0065505096884733716f,     -0.05141815616006597f,      0.01947595545199904f,     -0.07176168384004984f,      0.05619354199636016f,     -0.15793561144416274f,       0.4978349209674386f,       1.1150307161783575f,       0.9051841458066451f,       1.0315977424161105f,       0.9411466344972689f,       1.0115649467025414f,        0.953914790007016f,       1.0027163180004375f},
    {    -0.04230777628461944f,     0.006493751708802051f,     -0.05115640498672333f,      0.01926190721854927f,     -0.07118920070029229f,      0.05522439590917301f,      -0.1546221744625394f,      0.46257362074837943f,       1.1183441531599807f,       0.9042149997194578f,       1.0321702255558678f,       0.9409325862638189f,       1.0118266978758839f,       0.9538580320273445f,       1.0028876045440998f},
    {    -0.04175625850098011f,     0.006379428382094189f,     -0.05043646433235416f,     0.018878924779272818f,     -0.06998695869717203f,      0.05379052185930469f,     -0.15007826964548052f,      0.42754997295141084f,       1.1207038640676803f,        0.904093273093846f,        1.032455104782044f,       0.9412506454246401f,       1.0119806343140554f,       0.9542178100543662f,        1.003031464358329f},
    {    -0.04083251432108083f,     0.006209552869104455f,      -0.0492694068062771f,     0.018334093725313638f,     -0.06817547051426438f,      0.05192015984185569f,     -0.14439000516334058f,       0.3928799201140385f,       1.1220319615619103f,       0.9048377364497784f,       1.0324393437031558f,       0.9421019226388178f,        1.012020611544778f,       0.9549919602583523f,       1.0031435101652872f},
    {    -0.03954781832910607f,     0.005986596352571094f,    -0.047670173380432265f,      0.01763576346565729f,      -0.0657802230940538f,     0.049644223424616205f,     -0.13764827470001811f,      0.35867684533026284f,       1.1222539530691567f,       0.9064604226212084f,       1.0321123517427986f,       0.9434828660231056f,       1.0119415032686616f,       0.9561746358495289f,        1.003219670923489f},
    {    -0.03791658840493742f,     0.005713458526771388f,     -0.04565740318314382f,      0.01679344830734133f,     -0.06283138734302729f,      0.04699597217472255f,     -0.12994810704831877f,      0.32505095381093024f,       1.1212993103146158f,       0.9089664152469663f,       1.0314661624013794f,       0.9453852589955756f,        1.011739288704216f,       0.9577563492802373f,       1.0032562553661621f},
    {    -0.03595623231011687f,     0.005393434846517525f,    -0.043253232396581756f,     0.015817720684324514f,    -0.059363492327738084f,        0.044010675563848f,     -0.12138799306268971f,       0.2921086785036544f,       1.1191020216363423f,       0.9123536858531702f,       1.0304955920149828f,       0.9477962577017139f,       1.0114111302503823f,       0.9597240463045894f,       1.0032500117326255f},
    {    -0.03368696887130488f,     0.005030180872185791f,      -0.0404830643050027f,     0.014720097587329152f,      -0.0554150671119449f,     0.040725271015149854f,     -0.11206919493684026f,       0.2599521134680052f,       1.1156011227991498f,       0.9166129810942325f,       1.0291983770588566f,       0.9506984679459077f,       1.0109554404340164f,       0.9620612113293797f,       1.0031981829318386f},
    {    -0.03113162554067848f,    0.0046276740668576115f,     -0.03737531277374033f,     0.013512921283138024f,     -0.05102825361826867f,      0.03717801874698712f,     -0.10209504288236412f,      0.22867847848734515f,       1.1107412021399032f,       0.9217277613572122f,       1.0275752881955191f,       0.9540700612244727f,       1.0103719372022955f,       0.9647480032202667f,       1.0030985564225516f},
    {   -0.028315414308159807f,     0.004190173417799425f,     -0.03396112165003694f,     0.012209235438427356f,     -0.04624839410099919f,     0.033408156040636974f,     -0.09157022435399918f,      0.19837961816155664f,       1.1044728760226687f,        0.927674191561964f,        1.025630219438841f,       0.9578849291314682f,       1.0096616867235317f,       0.9677614204640583f,       1.0029495081479851f},
    {    -0.02526568811697729f,    0.0037221772672332565f,    -0.030274062764511042f,       0.0108226577801925f,     -0.04112359698831277f,      0.02945555351237373f,     -0.08060007099717131f,      0.16914153846679625f,       1.0967532307615324f,       0.9344211846099536f,       1.0233702509943803f,       0.9621128750881242f,       1.0088271329734706f,       0.9710754943335685f,       1.0027500399241205f},
    {   -0.022011680090425964f,    0.0032283797465958025f,    -0.026349815374914074f,     0.009367250432192182f,    -0.035704284991060944f,     0.025360375904959404f,     -0.06928984848387212f,      0.14104398349130903f,       1.0875462273796244f,       0.9419304975506528f,       1.0208056845413458f,       0.9667198420334421f,       1.0078721135068471f,       0.9746615084581344f,       1.0024998097489672f},
    {    -0.01858422801257038f,    0.0027136262142248707f,     -0.02222583003062345f,     0.007857389064724832f,    -0.030042729480595828f,     0.021162749830635267f,     -0.05774405435388476f,      0.11416005476239129f,       1.0768230658135367f,       0.9501568801489124f,       1.0179500499412464f,       0.9716681744099415f,       1.0068018609446547f,       0.9784882429725623f,       1.0021991545748072f},
    {    -0.01501548661800341f,    0.0021828680986524726f,    -0.017940979946094355f,     0.006307631983600681f,    -0.024192575209218845f,     0.016902440797948504f,     -0.04606572889045292f,      0.08855587527095714f,         1.06456250544118f,       0.9590482751525075f,       1.0148200825908058f,       0.9769169124871079f,       1.0056229898450555f,       0.9825222412019734f,         1.00184910516574f},
    {    -0.01133863033479424f,     0.001641117548457055f,    -0.013535203053498295f,     0.004732590263670289f,    -0.018208359483471645f,     0.012618541739250318f,    -0.034355783933468845f,       0.0642902999792415f,       1.0507511391063435f,       0.9685460691790851f,       1.0114356708802634f,       0.9824221167882898f,       1.0043434687688921f,       0.9867280966416225f,        1.001451392747997f},
    {  -0.0075875491898191524f,    0.0010934022849957686f,    -0.009049137958537982f,    0.0031468000030116846f,    -0.012145029902623656f,     0.008349175125547408f,     -0.02271235437027449f,      0.04141467426626084f,        1.035383618132559f,       0.9785853927687707f,       1.0078197734707206f,       0.9881372201268336f,       1.0029725774979723f,       0.9910687578109508f,        1.001008447249614f},
    {  -0.0037965406263604537f,    0.0005447210463908419f,    -0.004523757048699497f,     0.001564597736256573f,    -0.006057464742619719f,     0.004131210611796536f,    -0.011230176845630883f,      0.01997264142726867f,       1.0184628261600521f,       0.9890954677855585f,       1.0039983063636595f,       0.9940134045163317f,       1.0015208495143226f,       0.9955058484014745f,       1.0005233870182222f}
};


// Public methods ------------------------------------------------------------

uint16_t Osc::frequency() {
    return mFrequency;
}

void Osc::generate(int16_t buf[], size_t nsamples) {
    if (mMuted || mDeltaBuf.size() == 0) {
        // no delta changes, waveform is completely flat or the oscilator is muted
        std::fill_n(buf, nsamples, static_cast<int16_t>(0));
    } else {

        if (mRegenPeriod) {
            generatePeriods();
            mRegenPeriod = false;
        }

        CircularIterator<int16_t> src(mPeriodBuf.data(), mPeriodBufSize);
        src.setOffset(mPeriodPos);
        //CircularIterator<int16_t> src(periodBufPtr, periodBufPtr + mPeriodPos, periodBufPtr + mPeriodBufSize);

        std::copy_n(src, nsamples, buf);
        mPeriodPos = (mPeriodPos + nsamples) % mPeriodBufSize;

        //size_t lastIndex = -1;
        //Delta *delta = nullptr;
        //for (size_t i = nsamples; i--; ) {

        //    // the current delta is the floor of the delta counter
        //    size_t index = static_cast<size_t>(mDeltaCounter);
        //    if (index != lastIndex) {
        //        delta = &mDeltaBuf[mDeltaMap[index]];
        //    }

        //    if (index == delta->location) {
        //        // in transition
        //        size_t stepIndex = static_cast<size_t>((mDeltaCounter - index) * SINC_STEPS);
        //        *buf++ = delta->before + (delta->change * delta->stepSet[stepIndex]);
        //    } else if (index > delta->location) {
        //        // right side of the step (after transition)
        //        *buf++ = delta->after;
        //    } else {
        //        // left side of the step (before transition)
        //        *buf++ = delta->before;
        //    }

        //    lastIndex = index;
        //    mDeltaCounter += mDeltasPerSample;
        //    if (mDeltaCounter >= mWaveformSize) {
        //        // new period
        //        size_t periods = mDeltaCounter / mWaveformSize;
        //        // keep the counter within the period
        //        mDeltaCounter -= periods * mWaveformSize;
        //        float phaseShift = mPhaseOffset * periods;
        //        for (auto iter = mDeltaBuf.begin(); iter != mDeltaBuf.end(); ++iter) {
        //            float phase = iter->phase;
        //            phase += phaseShift;
        //            phase = fmodf(phase, STEP_PHASES);
        //            iter->phase = phase;
        //            iter->stepSet = STEP_TABLE[static_cast<size_t>(phase)];
        //        }
        //    }
        //}
    }
    

}

bool Osc::muted() {
    return mMuted;
}

void Osc::reset() {

}

void Osc::setFrequency(uint16_t frequency) {
    mFrequency = frequency;
    // regenerate the period on next call to period
    mRegenPeriod = true;
}


void Osc::setMute(bool muted) {
    mMuted = muted;
}


// protected methods ---------------------------------------------------------


Osc::Osc(float samplingRate, size_t multiplier, size_t waveformSize) :
    mMultiplier(multiplier),
    mWaveformSize(waveformSize),
    mFactor(samplingRate / Gbs::CLOCK_SPEED),
    mFrequency(Gbs::DEFAULT_FREQUENCY),
    mDeltaBuf(),
    mPeriodCount(0),
    mPeriodBuf(static_cast<size_t>(samplingRate / 4)),
    mPeriodBufSize(0),
    mPeriodPos(0),
    mRegenPeriod(true),
    mMuted(false)
{
    // assert that waveform size is a power of 2
    assert((mWaveformSize & (mWaveformSize - 1)) == 0);
}


void Osc::deltaSet(const uint8_t waveform[]) {

    // clear existing waveform
    mDeltaBuf.clear();

    // convert waveform to a delta buffer

    size_t bufsize = mWaveformSize / 2;
    // bitmask used to wrap -1 to bufsize-1 or bufsize to 0
    size_t mask = bufsize - 1;
    uint8_t lo; // keep lo out here cause we need the last one for initSample
    size_t waveIndex = 0;
    size_t deltaIndex = 0;

    // the starting volume is the first sample
    int16_t previous = SAMPLE_TABLE[waveform[0] >> 4];

    for (size_t i = 0; i != mWaveformSize; ++i) {

        uint8_t hi = waveform[waveIndex];
        lo = hi & 0xF;
        hi >>= 4;


        int8_t delta;
        if ((i & 1) == 1) {
            // for odd numbered indices, the delta is calculated by
            // subtracting the high nibble from the next sample and the current low nibble
            delta = lo - hi;
            ++waveIndex;
        } else {
            // even numbered indices, the delta is the lower nibble
            // minus the high nibble of the current byte
            delta = (waveform[(waveIndex + 1) & mask] >> 4) - lo;
        }

        if (delta) {
            Delta d;
            d.change = SAMPLE_TABLE[abs(delta)];
            if (delta < 0) {
                d.change = -d.change; 
            }
            d.location = static_cast<uint8_t>(i);
            d.before = previous;
            previous += d.change;
            d.after = previous;
            mDeltaBuf.push_back(d);
            ++deltaIndex;
        }
    }

    
    //size_t deltaCount = mDeltaBuf.size();

    // make sure we don't have a flat waveform
    //if (deltaCount > 0) {

        

        // adjust the duration of the last delta
        // since the sum of the duration must be mWaveformSize, we just add what's missing
        //mDeltaBuf.back().duration += mWaveformSize - durationCounter;

        // determine timing information for generation
        //calcDeltaTimings();

        // now we need to adjust the sample counter and the current delta
        // for the new waveform.
        //
        // Three options here:
        //  1. pick the nearest delta time of the new waveform
        //  2. pick the closest matching delta change of the new waveform
        //  3. reset the counter to 0 (new waveform starts at the beginning)
        //
        // old waveform
        //  _      ___
        //   |____|
        //        ^ current sample counter
        //
        // new waveform
        //    ______
        //  _|      |_
        // ^ ^      ^
        // 3 2      1
        //
        // the numbers above are the corresponding options
        //
        // we'll go with 3 since it's the easiest, will reconsider if the sound is wonky

        //mSampleCounter = 0.0f;
        //mDeltaIndex = mDeltaBuf.size() - 1;
        //mDelta = mDeltaBuf.back();
    //}

    
}

// private methods -----------------------------------------------------------


void Osc::generatePeriods() {

    // WIP, do not compile for now
    #if 0

    assert(mRegenPeriod);
    assert(mDeltaBuf.size() > 0);

    // determine sample counts for each delta
    size_t deltaCount = mDeltaBuf.size();
    CircularIterator<Delta> deltaCircle(mDeltaBuf.data(), deltaCount);
    Delta *curDelta = &*deltaCircle;
    float curCenter = curDelta->location * mSamplesPerDelta;
    for (size_t i = 0; i != deltaCount; ++i) {
        Delta *nextDelta = &*(++deltaCircle);
        float nextCenter = nextDelta->location * mSamplesPerDelta;
        float distance = nextCenter - curCenter;
        if (distance < 0.0f) {
            distance += mSamples
        }

        prevDelta = curDelta;
        curDelta = nextDelta;
    }

    size_t periodOffset = 0;
    uint8_t periodCounter = 0;
    uint8_t extraSample = 0;
    int16_t *periodData = mPeriodBuf.data();
    for (size_t period = 0; period != nperiods; ++period) {

        size_t periodSize = mSamplesPerPeriod + extraSample;
        CircularIterator<int16_t> periodIter(periodData, periodSize);
        periodIter.setOffset(periodOffset);

        size_t offset = periodOffset;
        for (auto iter = mDeltaBuf.begin(); iter != mDeltaBuf.end(); ++iter) {
            // flat part before the transition
            std::fill_n(periodIter, iter->samplesBefore, iter->before);
            periodIter += iter->samplesBefore;

            const float *stepSet;

            // transition
            for (size_t i = iter->samplesDuringBegin; i != iter->samplesDuringEnd; ++i) {
                *periodIter++ = static_cast<int16_t>(iter->change * stepSet[i] + 0.5f);
            }

            // flat part after the transition
            std::fill_n(periodIter, iter->samplesAfter, iter->after);
            periodIter += iter->samplesAfter;

        }

        periodData += periodSize;
        periodCounter += mSamplesPerPeriodF;
        if (periodCounter >= 0x10) {
            // >= 1.0 (Q4.4)
            periodCounter -= 0x10;
            extraSample = 1;
        } else {
            extraSample = 0;
        }
    }

    float phaseOffset;

    #endif
}


//void Osc::generateStep(int16_t *stepBuf, size_t phase, int16_t init, int16_t change) {
//    int16_t previous = init;
//    const float *sincSet = SINC_TABLE[phase];
//    for (size_t i = 0; i != SINC_STEPS; ++i) {
//        previous += change * sincSet[i];
//        stepBuf[i] = previous;
//    }
//}

}